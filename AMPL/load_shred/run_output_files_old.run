reset;

model DCOPF.mod;
data DCOPF.dat;


option solver Gurobi;


solve;


param power_flow_in{t in TIME_PERIODS,n in ZONES};

param power_flow_out{t in TIME_PERIODS,n in ZONES};


let { t in TIME_PERIODS,n in ZONES} power_flow_out[t,n] := 
    sum{l in LINES: line_from[l] == n} flow[l,t];
    
let {t in TIME_PERIODS,n in ZONES} power_flow_in[t,n] := 
    sum{l in LINES: line_to[l] == n} flow[l,t];

#power flow in    
for {n in ZONES} {
    printf ",%s", n > csv_power_in.csv;
}
printf "\n" >> csv_power_in.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_power_in.csv;
    for {n in ZONES} {
        printf ",%f", power_flow_in[n,t] >> csv_power_in.csv;
    }
    printf "\n" >> csv_power_in.csv;
}

#power flow out   
for {n in ZONES} {
    printf ",%s", n > csv_power_out.csv;
}
printf "\n" >> csv_power_out.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_power_out.csv;
    for {n in ZONES} {
        printf ",%f", power_flow_out[n,t] >> csv_power_out.csv;
    }
    printf "\n" >> csv_power_out.csv;
}
    
param power_flow_time{n in ZONES, t in TIME_PERIODS};
let {n in ZONES, t in TIME_PERIODS} power_flow_time[n,t] := 
    sum{l in LINES: line_from[l] == n} flow[l,t] - 
    sum{l in LINES: line_to[l] == n} flow[l,t];

display power_flow_time['A',13];

for {n in ZONES} {
    printf ",%s", n > csv_power_flows.csv;
}
printf "\n" >> csv_power_flows.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_power_flows.csv;
    for {n in ZONES} {
        printf ",%f", power_flow_time[n,t] >> csv_power_flows.csv;
    }
    printf "\n" >> csv_power_flows.csv;
}


for {n in ZONES} {
    printf ",%s", n > csv_load_shed.csv;
}
printf "\n" > csv_load_shed.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_load_shed.csv;
    for {n in ZONES} {
        printf ",%f", Load_shed[t,n] >> csv_load_shed.csv;
    }
    printf "\n" >> csv_load_shed.csv;
}


for {n in ZONES} {
    printf ",%s", n > csv_power.csv;
}
printf "\n" >> csv_power.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_power.csv;
    for {n in ZONES} {
        printf ",%f", sum{g in GENERATORS} Prod_generator[g,t,n] >> csv_power.csv;
    }
    printf "\n" >> csv_power.csv;
}


for {n in ZONES} {
    printf ",%s", n > csv_discharge.csv;
}
printf "\n" >> csv_discharge.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_discharge.csv;
    for {n in ZONES} {
        printf ",%f", sum{b in STORAGE} Discharge[b,t,n] >> csv_discharge.csv;
    }
    printf "\n" >> csv_discharge.csv;
}


for {n in ZONES} {
    printf ",%s", n > csv_charge.csv;
}
printf "\n" >> csv_charge.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_charge.csv;
    for {n in ZONES} {
        printf ",%f", sum{b in STORAGE} Charge[b,t,n] >> csv_charge.csv;
    }
    printf "\n" >> csv_charge.csv;
}

param Curtailment{TIME_PERIODS,ZONES};
let {t in TIME_PERIODS,n in ZONES} Curtailment[t,n] := wind_avail[t,n] * capacity_installed_gen['WIND',n] - Prod_generator['WIND',t,n]
+ solar_avail[t,n] * capacity_installed_gen['SOLAR',n] - Prod_generator['SOLAR',t,n]
+ capacity_installed_gen['GAS',n] - Prod_generator['GAS',t,n];

for {n in ZONES} {
    printf ",%s", n > csv_curtailment.csv;
}
printf "\n" >> csv_curtailment.csv;

# Write data for each time period
for {t in TIME_PERIODS} {
    printf "%d", t >> csv_curtailment.csv;
    for {n in ZONES} {
        printf ",%f", Curtailment[t,n] >> csv_curtailment.csv;
    }
    printf "\n" >> csv_curtailment.csv;
}



