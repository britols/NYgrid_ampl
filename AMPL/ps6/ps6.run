reset;

model ps6.mod;
data ps6.dat;


option solver Gurobi;

solve;

param max_flow{LINES};
let {l in LINES} max_flow[l] := max{t in TIME_PERIODS} flow[l,t];

param min_flow{LINES};
let {l in LINES} min_flow[l] := min{t in TIME_PERIODS} flow[l,t];

display min_flow, max_flow;

param load_shed{n in ZONES};
let {n in ZONES} load_shed[n] := sum{t in TIME_PERIODS}  Curtailment[t,n];
	  

param total_demand;
let total_demand := sum{t in TIME_PERIODS,n in ZONES} fixed_demand[t,n];

display total_cost;
display total_cost/total_demand;
display capacity_installed_stor;
display capacity_installed_ger;
display load_shed;

#for{n in ZONES} {
#	for {g in GENERATORS} {
#		let operating_cost[g,n] := 0;
#	}
#}

#var capacity_installed_ger{g in GENERATORS,n in ZONES} >= 0;
#var capacity_installed_stor{b in STORAGE,n in ZONES} >= 0;

let {n in ZONES,g in GENERATORS} capacity_installed_ger[g,n] := 2000;
let {n in ZONES,b in STORAGE} capacity_installed_stor[b,n] := 2000;

let capacity_installed_ger['WIND','G'] := 0;
let capacity_installed_ger['WIND','H'] := 0;
let capacity_installed_ger['WIND','I'] := 0;

fix capacity_installed_ger;
fix capacity_installed_stor;

option solver Gurobi;

solve;


#display {g in GENERATORS, n in ZONES} sum{t in TIME_PERIODS} Prod_generator[g,t,n];
#display {b in STORAGE, n in ZONES} sum{t in TIME_PERIODS} (Discharge[b,t,n]);
#display {b in STORAGE, n in ZONES} sum{t in TIME_PERIODS} (Charge[b,t,n]);
#display {n in ZONES} sum{t in TIME_PERIODS} (Curtailment[t,n]);


#isplay {n in ZONES} max{t in TIME_PERIODS} fixed_demand[t,n];
#display {n in ZONES} sum{t in TIME_PERIODS} fixed_demand[t,n];
#display {n in ZONES} sum{t in TIME_PERIODS,g in GENERATORS} Prod_generator[g,t,n];


#printf " Node \t Demand  \n" > output/dual.csv;
#for {t in TIME_PERIODS} {
	#printf "%s \t",
	#t > output/dual.csv;
	#	for{n in ZONES}{
	#	    printf "%.2f \t", 
	#	    SystemBalance[t,n].dual > output/dual.csv;
	#	} 
#	printf "\n"  > output/dual.csv;
#}
#close output/dual.csv;

#-----------------------
# C)
#-----------------------
param total_demand;
let total_demand := sum{t in TIME_PERIODS,n in ZONES} fixed_demand[t,n];

print "cost per MWh of demand ";
display total_cost/total_demand;



param gen_profit{g in GENERATORS, n in ZONES};
let {g in GENERATORS, n in ZONES} gen_profit[g,n] := 
    sum{t in TIME_PERIODS} ((SystemBalance[t,n].dual - operating_cost[g,n]) * Prod_generator[g,t,n]) - 
    capacity_cost_gen[g,n] * capacity_installed_ger[g,n];

param gen_profit_by_unit{g in GENERATORS, n in ZONES};
let {g in GENERATORS, n in ZONES: capacity_installed_ger[g,n] > 0} 
    gen_profit_by_unit[g,n] := gen_profit[g,n] / capacity_installed_ger[g,n];
  
display gen_profit_by_unit;
 

# First, declare the parameter
param avg_price2 {n in ZONES};

# Then, after solving the model, calculate it using the 'let' command
let {n in ZONES} avg_price2[n] := sum{t in TIME_PERIODS} SystemBalance[t,n].dual / card(TIME_PERIODS);

# Display the results
#display avg_price2;

# For storage
param storage_profit{b in STORAGE, n in ZONES};
let {b in STORAGE, n in ZONES} storage_profit[b,n] := 
    sum{t in TIME_PERIODS} (SystemBalance[t,n].dual * Discharge[b,t,n]) - 
    sum{t in TIME_PERIODS} (SystemBalance[t,n].dual * Charge[b,t,n]) - 
    capacity_cost_stor[b] * capacity_installed_stor[b,n];
    
param storage_profit_per_unit{b in STORAGE, n in ZONES};
let {b in STORAGE, n in ZONES: capacity_installed_stor[b,n] > 0} 
    storage_profit_per_unit[b,n] := storage_profit[b,n] / capacity_installed_stor[b,n];
  
  
display storage_profit_per_unit;

#param sel2;

#let sel2 := 3519;
#display {n in ZONES} fixed_demand[sel2,n];
#display {g in GENERATORS,n in ZONES} Prod_generator[g,sel2,n];
#display {g in STORAGE,n in ZONES} Charge[g,sel2,n];
#display {n in ZONES} solar_avail[sel2,n]* capacity_installed_ger['SOLAR',n];
#display {n in ZONES} wind_avail[sel2,n] * capacity_installed_ger['WIND',n];
#display {n in ZONES} SystemBalance[sel2,n].dual;
#display {n in ZONES} sum{l in LINES} line_incidence[l,n] * flow[l,sel2];
#display {n in ZONES} Curtailment[sel2,n];


#display {g in GENERATORS,n in ZONES} (operating_cost[g,n] * Prod_generator[g,1,n]);
#display {g in GENERATORS,n in ZONES} capacity_cost_gen[g,n] * capacity_installed_ger[g,n];


#-----------------------
# D)
#-----------------------

param nIter default 10;
set ITERATIONS :={1..nIter};
param StepSize;

let StepSize := .001;

param CostRecord{ITERATIONS};
param CostRecordbyDemand{ITERATIONS};
for {i in ITERATIONS} {

	display i;
	
	let {n in ZONES,g in GENERATORS: capacity_installed_ger[g,n] > 0} capacity_installed_ger[g,n] := (capacity_installed_ger[g,n] + StepSize*gen_profit_by_unit[g,n]);
	let {n in ZONES,b in STORAGE: capacity_installed_stor[b,n] > 0} capacity_installed_stor[b,n] := (capacity_installed_stor[b,n] + StepSize*storage_profit_per_unit[b,n]);
	
	solve;
	
	let {g in GENERATORS, n in ZONES} gen_profit[g,n] := 
    sum{t in TIME_PERIODS} ((SystemBalance[t,n].dual - operating_cost[g,n]) * Prod_generator[g,t,n])
    - capacity_cost_gen[g,n] * capacity_installed_ger[g,n];

	let {g in GENERATORS, n in ZONES: capacity_installed_ger[g,n] > 0} 
    gen_profit_by_unit[g,n] := gen_profit[g,n] / capacity_installed_ger[g,n];
  
	let {b in STORAGE, n in ZONES} storage_profit[b,n] := 
    sum{t in TIME_PERIODS} (SystemBalance[t,n].dual * (Discharge[b,t,n] - Charge[b,t,n]))
    - capacity_cost_stor[b] * capacity_installed_stor[b,n];
    
	let {b in STORAGE, n in ZONES: capacity_installed_stor[b,n] > 0} 
    storage_profit_per_unit[b,n] := storage_profit[b,n] / capacity_installed_stor[b,n];
    
    let total_demand := sum{t in TIME_PERIODS,n in ZONES} fixed_demand[t,n];
    
    let CostRecord[i] := total_cost;
    let CostRecordbyDemand[i] := total_cost/total_demand;
    
    #display capacity_installed_ger;
    #display capacity_installed_stor;
    #display gen_profit_by_unit;
	#display storage_profit_per_unit;
    
    
}
  
let {g in GENERATORS, n in ZONES} gen_profit[g,n] := 
    sum{t in TIME_PERIODS} ((SystemBalance[t,n].dual - operating_cost[g,n]) * Prod_generator[g,t,n]) 
    - capacity_cost_gen[g,n] * capacity_installed_ger[g,n];
    
let {g in GENERATORS, n in ZONES: capacity_installed_ger[g,n] > 0} 
    gen_profit_by_unit[g,n] := gen_profit[g,n] / capacity_installed_ger[g,n];

let {b in STORAGE, n in ZONES} storage_profit[b,n] := 
    sum{t in TIME_PERIODS} (SystemBalance[t,n].dual * Discharge[b,t,n]) 
    -  sum{t in TIME_PERIODS} (SystemBalance[t,n].dual * Charge[b,t,n]) 
    - capacity_cost_stor[b] * capacity_installed_stor[b,n];
    
let {b in STORAGE, n in ZONES: capacity_installed_stor[b,n] > 0} 
    storage_profit_per_unit[b,n] := storage_profit[b,n] / capacity_installed_stor[b,n];
  
fix capacity_installed_ger;
fix capacity_installed_stor;

solve;

let total_demand := sum{t in TIME_PERIODS,n in ZONES} fixed_demand[t,n];

print "cost per MWh of demand ";
display total_cost/total_demand;

let {g in GENERATORS, n in ZONES} gen_profit[g,n] := 
	sum{t in TIME_PERIODS} ((SystemBalance[t,n].dual - operating_cost[g,n]) * Prod_generator[g,t,n]) 
	- capacity_cost_gen[g,n] * capacity_installed_ger[g,n];

let {g in GENERATORS, n in ZONES: capacity_installed_ger[g,n] > 0} 
	gen_profit_by_unit[g,n] := gen_profit[g,n] / capacity_installed_ger[g,n];
  
let {b in STORAGE, n in ZONES} storage_profit[b,n] := 
    sum{t in TIME_PERIODS} (SystemBalance[t,n].dual * (Discharge[b,t,n] - Charge[b,t,n])) 
    - capacity_cost_stor[b] * capacity_installed_stor[b,n];
    
let {b in STORAGE, n in ZONES: capacity_installed_stor[b,n] > 0} 
    storage_profit_per_unit[b,n] := storage_profit[b,n] / capacity_installed_stor[b,n];
    
display gen_profit_by_unit;
display storage_profit_per_unit;



display capacity_installed_ger;
display capacity_installed_stor;


#-----------------------
# E)
#-----------------------
display CostRecordbyDemand;

#-----------------------
# F)
#-----------------------
display capacity_installed_ger;
display capacity_installed_stor;